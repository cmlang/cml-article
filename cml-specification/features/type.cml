
// Model (Abstract Syntax)

abstract concept TypedElement: NamedElement
{
    type: Type?;

    typeRequired: Boolean = true;
    typeAllowed: Boolean = true;

    invariants
    {
        given typeRequired require typeAllowed;
        given not typeAllowed require not typeRequired;

        // Notice that we cannot add any invariant on the "type" property,
        // because the concrete syntax allows the instantiation of malformed models,
        // which are validated once they have been synthesized.
    }
}

concept Type: NamedElement;

// Validator (Well-Formedness Rules)

command validateType(type: Type)
{
    invoke validatePrimitiveType(type);
}

command validateTypedElement(element: TypedElement)
{
    invoke validateNamedElement(element);

    invoke validateTypeRequired(element);

    invoke validateTypeNotAllowed(element);
}

// Concrete Syntax

concept TypeNode: Node
{
    name: String;

    type: Type?;
}

concept TypedElementNode: NamedElementNode
{
    typeNode: TypeNode;
}

command SyntaxTreeBuilder.includeType(location: SourceLocation, name: String)
{
    let typeNode = new TypeNode;

    ensure
    {
        typeNode.location = location;

        typeNode.name = name;

        syntaxTree.currentTypeNode = typeNode;
    }
}

// Model Synthesis (Synthesized Attributes / Inherited Scopes)

command synthesizeType(typeNode: TypeNode, parentScope: Scope)
{
    let type = new Type;
    invoke synthesizeNamedElement(type, typeNode, parentScope);

    ensure
    {
        typeNode.type = type;
    }
}

command synthesizeTypedElement(element: ~TypedElement, elementNode: TypedElementNode, parentScope: Scope)
{
    invoke synthesizeNamedElement(element, elementNode, parentScope);

    inoke synthesizeType(elementNode.typeNode, parentScope);

    ensure
    {
        element.type = elementNode.typeNode.type;
    }
}
