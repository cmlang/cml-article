
// Model (Abstract Syntax)

abstract concept ModelElement
{
    location: SourceLocation;
}

abstract concept NamedElement: ModelElement
{
    name: String;
    scope: Scope;
}

abstract concept TypedElement: NamedElement
{
    type: Type?;

    typeRequired: Boolean = true;
    typeAllowed: Boolean = true;

    invariants
    {
        given typeRequired require typeAllowed;
        given not typeAllowed require not typeRequired;

        // Notice that we cannot add any invariant on the "type" property,
        // because we want to allow the instantiation of malformed models,
        // which will be validated at some point.
    }
}

// Validator (Well-Formedness Rules)

command validateNamedElement(element: NamedElement)
{
    invoke validateNameConflicts(element);
}

command validateTypedElement(element: TypedElement)
{
    invoke validateNamedElement(element);

    invoke validateTypeRequired(element);

    invoke validateTypeNotAllowed(element);
}

// Concrete Syntax

concept NamedElementNode: Node
{
    name: String;
}

concept TypedElementNode: NamedElementNode
{
    typeNode: TypeNode;
}

// Model Synthesis (Synthesized Attributes / Inherited Scopes)

command synthesizeModelElement(element: ~ModelElement, elementNode: Node)
{
    ensure
    {
        element.location = elementNode.location;
    }
}

command synthesizeNamedElement(element: ~NamedElement, elementNode: NamedElementNode, parentScope: Scope)
{
    invoke synthesizeModelElement(element, elementNode);

    ensure
    {
        element.name = elementNode.name;
        element.scope = parentScope;
    }
}

command synthesizeTypedElement(element: ~TypedElement, elementNode: TypedElementNode, parentScope: Scope)
{
    invoke synthesizeNamedElement(element, elementNode, parentScope);

    inoke synthesizeType(elementNode.typeNode, parentScope);

    ensure
    {
        element.type = elementNode.typeNode.type;
    }
}
