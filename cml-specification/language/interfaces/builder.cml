
interface ModelBuilder
{
    command startBuilding();
    command finishBuilding(): Model;

    @BeforeRule("model")
    command createModelNode(location: SourceLocation);

    @BeforeRule("modelElement")
    command createModelElementNode(location: SourceLocation);

    @AfterRule("modelElement")
    command includeModelElementNode(location: SourceLocation);

    @AfterRule("concept")
    command includeConceptNode(location: SourceLocation, name: String);

    @AfterRule("target")
    command includeTargetNode(location: SourceLocation, name: String);

    @BeforeRule("propertyList")
    command createPropertyList(location: SourceLocation);

    @AfterRule("property")
    command includeProperty(location: SourceLocation, name: String, string: String);

    @AfterRule("type")
    command includeType(location: SourceLocation, name: String);
}

root buildingSite: BuildingSite;

concept BuildingSite
{
    modelNode: ModelNode?;

    currentModelElementNode: ModelElementNode?;
    currentPropertyListNode: PropertyListNode?;
    currentTypeNode: TypeNode?;

    errors: list of Error*;
}

command SyntaxTreeBuilder.startBuilding()
{
    ensure
    {
        not buildingSite.modelNode;
        not buildingSite.currentModelElementNode;
        not buildingSite.currentPropertyListNode;
        not buildingSite.currentTypeNode;
        errors | count = 0;
    }
}

command SyntaxTreeBuilder.finishBuilding(): ModelNode
{
    require buildingSite.modelNode;

    invoke synthesizeModel(buildingSite.modelNode);
    invoke validateModel(buildingSite.modelNode.model);

    ensure
    {
        buildingSite.modelNode.model.errors = buildingSite.errors;
    }

    return buildingSite.modelNode.model;
}

annotation BeforeRule(ruleName: String)
{
    usages = ["command"];
}

annotation AfterRule(ruleName: String)
{
    usages = ["command"];
}
