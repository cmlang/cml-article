
// Model (Abstract Syntax)

concept Model: NamedElement
{
    concepts: list of Concept*;
    targets: list of Target*;

    errors: list of Error*;
}

// Validator (Well-Formedness Rules)

command validateModel(model: Model)
{
    for concept in model.concepts
        invoke validateConcept(concept);

    for target in model.targets
        invoke validateTarget(target);
}

// Concrete Syntax

concept ModelNode: Node
{
    modelElementNodes: list of ModelElementNode*;

    model: Model?;
}

concept ModelElementNode: Node
{
    conceptNode: ConceptNode?;
    targetNode: TargetNode?;
}

command ModelBuilder.createModelNode(location: SourceLocation)
{
    let modelNode = new ModelMode;

    ensure
    {
        modelNode.location = location;

        buildingSite.modelNode = model;
    }
}

command ModelBuilder.createModelElementNode(location: SourceLocation)
{
    let modelElementNode = new ModelElementNode;

    ensure
    {
        modelElementNode.location = location;

        buildingSite.currentModelElementNode = modelElementNode;

        not buildingSite.currentPropertyListNode;
    }
}

command ModelBuilder.includeModelElementNode()
{
    require
    {
        buildingSite.modelNode;
        buildingSite.currentModelElementNode;
    }

    ensure buildingSite.modelNode.modelElementNodes | includes buildingSite.currentModelElementNode;
}

// Model Synthesis (Synthesized Attributes / Inherited Scopes)

command synthesizeModel(modelNode: ModelNode)
{
    let model = new Model;
    synthesizeModelElement(model, modelNode);

    let scope = createRootScope(model);
    for modelNode.modelElementNodes
    {
        given conceptNode invoke synthesiseConcept(conceptNode, scope);
        given targetNode invoke synthesiseTarget(targetNode, scope);
    }

    ensure
    {
        model.concepts = modelNode.modelElementNodes.conceptNode.concept;
        model.targets = modelNode.modelElementNodes.targetNode.target;

        modelNode.model = model;
    }
}
