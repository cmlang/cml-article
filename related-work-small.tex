\section{Related Work}\label{sec:related}

This section compares CML to other languages, tools and frameworks
that can also generate code from conceptual models.
Each paragraph covers a different category,
enumerating specific solutions and characterizing their relevance to CML,
and also their differences.

When compared to CML, the text-based languages are the most relevant.
MPS \cite{voelter} is a development environment for DSLs.
Strictly speaking, its DSLs are not textual,
since their AST is directly edited on projectional editors.
However, the editors allow textual representations.
Unlike MPS, the DSLs created with the M language \cite{mlang} are truly textual. It was part of the discontinued Oslo project from Microsoft,
which incorporated into Visual Studio similar capabilities to what is available on MPS.
Xtext/Xtend \cite{xtext} allows the definition of textual DSLs
to generate code from conceptual models edited on Eclipse.
It is similar to the Oslo project from Microsoft,
and based on EMF \cite{emf}.
MM-DSL \cite{mm-dsl}, on the other hand,
allows the definition of metamodels (abstract syntax; not the actual DSLs),
which serve as input to generate domain-specific modeling tools.
XML may also be used for conceptual modeling,
and XSLT then used to create the templates for code generation,
as shown by Gheraibia et all \cite{xslt}.
Observe that, except for the last one,
most of these solutions enable modeling via DSLs,
while CML is a generic language for modeling in any domain.

Graphical languages also have some relevance to CML,
despite the latter being a textual language,
because the former have also been used to generate code in other target languages.
MPS \cite{voelter},
besides the textual models,
also allows the creation of graphical models.
FCML \cite{fcml}, on other hand,
incorporates and extends conceptual modeling languages (ER, UML, and BPMN)
via the OMNILab tool in order to generate code.
MetaEdit+ \cite{metaedit} is another development environment
that allows the creation of modeling tools
and code generators for visual DSLs.
As mentioned previously in this article,
MDA \cite{mda} is the initiative from OMG
to use UML \cite{uml} for model-driven development.
IFML \cite{ifml} is an example from OMG of a high-level language
that can be used to generate user interfaces on different platforms,
such as the Web, or on mobile devices.
The major drawback of graphical languages,
as covered in section \ref{sec:why},
is their difficulty to integrate seamlessly with the workflow, tools and mindset of software developers.

Frameworks also allow code generation from conceptual models, but lack a modeling language -- graphical or textual.
EMF \cite{emf} is a classical example,
where modeling is done via editors on Eclipse or via a programming interface,
and the models are stored in the ECORE/XML format.
Frameworks may also be used as the infrastructure of modeling languages.
EMF, for example, is the framework supporting Xtext \cite{xtext}.
Conceivably, other modeling languages may also target EMF.
In fact, CML's extensible compiler allows the implementation of templates that target EMF.

As seen in previous sections,
the CML compiler uses StringTemplate \cite{st} as the language for its code generation templates.
There are other template languages designed for code generation from conceptual models.
Xpand \cite{xpand} allows the definition of templates with multiple variability regions.
EGL \cite{egl} is another language that allows code generation from models.
MOFScript \cite{mofscript} allows code generation from models defined
by any type of metamodel.
JET \cite{jet} allows code generation from EMF \cite{emf} models.
One strength of StringTemplate is its extensibility mechanisms.
It is possible to define a core set of templates that define patterns,
and then extend them with the specifics of each target language or technology.
It is also possible to share templates as libraries,
which can be further extended for specific purposes by third-parties.
Xpand also allows this level of extensibility.

Just like CML, there are programming languages
that provide the ability to declare bidirectional associations.
DSM \cite{balzer} is an object-oriented programming language with support for associations.
Fibonacci \cite{fibonacci}  is programming language for object-oriented databases
that allow the modeling of association roles.
ASSOCIATION\# \cite{cardoso}, on the other hand,
is an extension to C\# that allows the modeling of associations.
Likewise, RelJ \cite{bierman} is a Java extension with support for associations.
One key drawback of these languages is the fact that their conceptual models
cannot be reused to generate code in any other language or technology;
they are, for all intents and purposes, the target language.

There are also other conceptual languages
whose original focus has not been to support code generation or implementation,
but to serve solely as modeling artifacts.
Languages, such as OWL \cite{owl2} and Telos \cite{telos},
have been designed as ontology metamodels
to support the representation and storage of knowledge,
and to allow automated reasoning from knowledgebases.
OWL being the \emph{lingua franca} of the semantic web,
while Telos has been created to store ontologies in a object-oriented database.
Other languages, like UML \cite{uml} and ER \cite{er},
have been originally intended as tools to support the analysis and design of software systems,
and only after sometime have been repurposed for model-driven software development.
The relevance of these languages to CML comes from the expressivity power
their metamodels provide for conceptual modeling.
For that reason,
when convenient and appropriate,
CML should continue to expand its capabilities
by borrowing features from these languages.
