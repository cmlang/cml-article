\section{Why A New Language?}\label{sec:why}

Thalheim \cite{thalheim} has observed that
the choice of a conceptual modeling language has to do with its purpose.
He suggests that
a language is just a \emph{carrier} mapping some properties of the \emph{origin} (the problem space)
that can provide utility to its users.

In this context, the purpose of the CML language is being a tool
that allows software developers to transform text-based conceptual models
into executable code of an extensible range of technologies.
In order to achieve this purpose,
a new language is designed with the following goals (among others):

\begin{itemize}

\item \emph{Developer Experience}:
CML follows the principle ``the model is the code'' as laid out on the \emph{Conceptual-Model Programming} (CMP) manifesto \cite{cmp}.
Furthermore,
CML is also intended to enable software developers to do \emph{conceptual modeling}
on the same workflow they are used to doing \emph{programming};
that is, using text editors and a compiler.
CML strives to \emph{not only be} the code (as advocated by CMP),
but also \emph{look like} code (syntactically speaking),
pursuing compatibility with developers' mindset, toolset and workflow.
By providing its own syntax based on existing programming languages,
CML then promotes the \emph{modeling-as-programming} approach.
The UML \cite{uml} notation, on the other hand,
being graphical,
is not suited for mainstream, textual programming.
However, the \emph{Human Usable Textual Notation} (HUTN) \cite{hutn} is a textual syntax for MOF-based \cite{mof} metamodels,
and as such, it can also be used for UML models.
The syntax of the structural (static) elements of CML models is based on HUTN.

\item \emph{Language Evolution}:
This initial version is being designed for the validation of the model-driven development approach offered by CML.
Unlike the expressive power seen on UML \cite{uml} and OWL 2 \cite{owl2} with their breadth of features,
the CML language initially supports generalization/specialization,
bidirectional associations (with zero-or-one and zero-or-many cardinality)
and the ability to define derived attributes and associations with OCL-like expressions.
These features have already allowed the specification of CML compiler's own metamodel in CML itself.
The CML compiler is thus the first system used to validate CML's aplicability,
and will continue to do so as the language evolves.

\item \emph{Extensible Target Generation}:
Some of the language features should enable the generation of code
into a wide range of target languages and technologies.
Among the features that must be provided by the CML language,
it is the ability to break models into modules (already available);
the ability to share modules as libraries (planned);
the ability to specify different code generation targets (already available);
and the ability to annotate model elements in order to provide more information
for specific targets during code generation (also planned).
In order to effectively support code generation,
these language features must be available in a single language,
so that they can be compatible with each other and with the compiler backend.

\end{itemize}

Section \ref{sec:related} provides further motivation for developing CML,
comparing it to related work.
