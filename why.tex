\section{Why A New Language?}\label{sec:why}

Thalheim \cite{thalheim} has observed that
the choice of a conceptual modeling language has to do with its purpose.
He suggests that
a language is just a \emph{carrier} mapping some properties of the \emph{origin} (the problem space)
that can provide utility to its users. 

In this context, the purpose of the CML language is being a tool
that allows software developers to transform text-based conceptual models
into executable code of an extensible range of technologies.
In order to achieve this purpose,
a new language is designed with the high-level goals presented in the following subsections.

\subsection{Developer Experience}

CML follows the principle laid out on the \emph{Conceptual-Model Programming} (CMP) manifesto \cite{cmp}:

\begin{quote}
``Conceptual modeling is programming.
The conceptual-model instance is the code,
i.e., instead of `the code is the model,'
the phrase now becomes `the model is the code.'
A conceptual-model compiler assures that program execution corresponds to the conceptual specification,
thus making the conceptual-model instance directly executable.''
\end{quote}

Furthermore,
CML is also intended to enable software developers to do \emph{conceptual modeling} on the same workflow they are used to doing \emph{programming}.
CML strives to \emph{not only be} the code (as advocated by CMP),
but also \emph{look like} code (syntactically speaking),
pursuing compatibility with developers' mindset, toolset and workflow.
By providing its own syntax based on existing programming languages,
CML then promotes the \emph{modeling-as-programming} approach. 

The UML \cite{uml} notation, on the other hand,
being graphical,
is not suited for mainstream, textual programming.
However, the \emph{Human Usable Textual Notation} (HUTN) \cite{hutn} is a textual syntax for MOF-based \cite{mof} metamodels,
and as such, it can also be used for UML models.
The syntax of the structural (static) elements of CML models is based on HUTN.

The OWL 2 standard, as another example, provides the Manchester \cite{owl2manchester} syntax,
which is intended to be user-friendly.
However, it does not resemble the syntax of commonly used, block-based, imperative programming languages,
such as C \cite{clang} and its syntax-alike descendants.
Manchester's syntax is also unlike the syntax of declarative, query languages, such as SQL \cite{sql}.

Using CML,
and its familiar syntax (as we shall demonstrate in the next sections),
it is expected that developers can raise the abstraction level of their programs.

\subsection{Language Evolution}

CML is expected to evolve with its compiler, and the tooling around it.
Unlike the expressive power seen on UML \cite{uml} and OWL 2 \cite{owl2} with their breadth of features,
the CML language and its extensible compiler intentionally support a limited number of features and scenarios.

This first version has been designed for the initial validation of the model-driven development approach taken by CML.
As developers provide feedback,
new language features may be iteratively added in order to enable the extensible CML compiler to support new modeling/development scenarios.

\subsection{Extensible Target Generation}

Some of the language features enable the generation of code into a wide range of target languages and technologies. Among the features that must be provided by the CML language, there is the ability to:

\begin{itemize}
\item break models into modules that can be shared as libraries;
\item specify different code generation targets;
\item and annotate model elements in order to provide more information for specific targets during code generation.
\end{itemize}

These features need to be available in a single language, they have to compatible with each other and with the code generation backend.

