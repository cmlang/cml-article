\section{Related Work}\label{sec:related}

The following subsections compare CML to other languages, tools and frameworks
that can also generate code from conceptual models.
Each subsection covers a different category,
enumerating specific solutions and characterizing their relevance to CML, and also their differences. 

\subsection{Textual Languages}

This subsection covers existing text-based languages designed to enable code generation from conceptual models.
When compared to CML, the following languages are the most relevant,
because they are all textual languages designed for code generation:

\begin{itemize}
\item MPS \cite{voelter}
\item Xtext/Xtend \cite{xtext}
\item M Language \cite{mlang}
\item MM-DSL \cite{mm-dsl}
\item XML/XSLT \cite{xslt}
\item IFML \cite{ifml}
\end{itemize}

Observe that most of the solutions listed above enable modeling via DSLs, while CML is a generic language for modeling in any domain.

\subsection{Graphical Languages}

This subsection covers existing graphical languages designed to enable code generation from conceptual models.
Despite CML being a textual language,
the following graphical languages still have some relevance,
because they have also been used to generate code in other target languages:

\begin{itemize}
\item MPS \cite{voelter}
\item FCML \cite{fcml}
\item MetaEdit+ \cite{metaedit}
\item MDA \cite{mda}
\end{itemize}

The major drawback behind graphical languages,
as covered in section \ref{sec:why},
is their difficulty to integrate seamlessly with the workflow, tools and mindset of software developers.

\subsection{Frameworks}

Frameworks allow code generation from conceptual models, but lack a modeling language -- graphical or textual. 
EMF is a classical example,
where modeling is done via editors on Eclipse or via a programming interface,
and the models are stored in the ECORE/XML format. 

Frameworks may also be used as the infrastructure of modeling languages.
EMF, for example, is the framework supporting Xtext.
Conceivably, other modeling languages may also target EMF.
In fact, CML's extensible compiler allows the implementation of templates that target EMF.

\subsection{Template Languages}

As seen in previous sections,
the CML compiler uses StringTemplate as the language for its code generation templates.
There are other template languages designed for code generation from conceptual models:

\begin{itemize}
\item Xpand \cite{xpand}
\item EGL \cite{egl}
\item MOFScript \cite{mofscript}
\item JET \cite{jet}
\end{itemize}

One major strength of StringTemplate over the options above is its extensibility mechanisms.
It is possible to define a core set of templates that define patterns, 
and then extend them with the specifics of each target language or technology.
It is also possible to share templates as libraries,
which can be further extended for specific purposes by third-parties.

\subsection{Languages Supporting Associations}

Just as CML,
and unlike most programming languages,
there are a number of languages that provide the ability to declare bidirectional associations:

\begin{itemize}
\item ASSOCIATION\# \cite{cardoso}
\item DSM \cite{balzer}
\item RelJ \cite{bierman}
\item Fibonacci \cite{fibonacci}
\end{itemize}

One key drawback of the languages listed above is the fact that their conceptual models
cannot be reused to generate code in any other language or technology;
they are, for all intents and purposes, the target language.

\subsection{Other Languages}

There are also other conceptual languages whose original focus has not been to support code generation or implementation,
but to serve solely as modeling artifacts.

Languages, such as OWL and Telos, have been designed as ontology metamodels
to support the representation and storage of knowledge,
and to allow automated reasoning from knowledgebases.
OWL being the \emph{lingua franca} of the semantic web,
while Telos has been created to store ontologies in a object-oriented database.
Other languages, like UML and ER, have been originally intended as tools to support the analysis and design of software systems, and only after sometime have been repurposed for model-driven software development.

The relevance of these languages to CML comes from the expressivity power their metamodels provide for conceptual modeling. For that reason, when convenience and appropriate, CML should remain to expand its capabilities by borrowing features from these languages.
