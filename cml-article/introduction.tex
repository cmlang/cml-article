\section{Introduction}
%
In order to address the challenges of the ever-changing, increasingly distributed technologies used on software systems, the Model-Driven Architecture (MDA \cite{mda}) initiative by the Object Management Group (OMG) has been promoting model-driven software development.
In particular, MDA has guided the use of high-level models (created with OMG standards, such as UML \cite{uml}, OCL \cite{ocl} and MOF \cite{mof}) to derive software artifacts and implementations via automated transformations.
As one of its value propositions, the MDA guide \cite{mda} advocates:
\begin{quote}``Automation reduces the time and cost of realizing a design, reduces the time and cost for changes and maintenance and produces results that ensure consistency across all of the derived artifacts. For example, manually producing all of the web service artifacts required to implement a set of processes and services for an organization is difficult and error-prone. Producing execution artifacts from a model is more reliable and faster.''\end{quote} 

Even though MDA provides guidance and standards that can be used to realize its vision, it leaves to software vendors the task of providing the tools that automate the process of generating the implementations from the models.

The key role played by tools has been demonstrated by Voelter \cite{voelter} in his \emph{Generic Tools, Specific Languages} approach for model-driven software development. In his approach, Voelter \cite{voelter} has used domain-specific languages (DSL's) with the Metaprogramming System (MPS) in order to generate the software artifacts.
Unlike MDA, which is based on UML/MOF models, MPS allows the specification of models using domain-specific editors.
MPS itself is a generic tool, but it enables the definition of the abstract syntax, the editors and the code generators for DSL's.

The conceptual modeling language and extensible compiler presented here are an alternative approach to MPS.
While the latter is a fully integrated development environment based on domain-specific languages and their projectional editors, the former (hereby called CML) is a compiler that has:
\begin{itemize}
\item as \emph{input}, source files defined using its own conceptual language, which provides an abstract syntax similar to (but smaller than) a combination of UML \cite{uml} and OCL \cite{ocl}; 
\item and, as \emph{output}, any target languages based on extensible templates, which may be provided by the compiler's base library, by third-parties, or even by the developers themselves.
\end{itemize}
