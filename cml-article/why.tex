\section{Why A New Language?}\label{sec:why}

Instead of using standard, richer languages, such as OWL 2 \cite{owl2} and UML \cite{uml}, there are two primary reasons why a new programming language is proposed here, which are explained in the follow subsections.

\subsection{Developer Experience}

CML follows the following principle laid out on the \emph{Conceptual-Model Programming} (CMP) manifesto \cite{cmp}:

\begin{quote}
``Conceptual modeling is programming.
The conceptual-model instance is the code,
i.e., instead of `the code is the model,'
the phrase now becomes `the model is the code.'
A conceptual-model compiler assures that program execution corresponds to the conceptual specification,
thus making the conceptual-model instance directly executable.''
\end{quote}

Furthermore,
CML is also intended to enable software developers to do \emph{conceptual modeling} on the same workflow they are used to doing \emph{programming}.
CML strives to \emph{not only be} the code (as advocated by CMP),
but also \emph{look like} code (syntactically speaking),
pursuing compatibility with developers' mindset, toolset and workflow.
By providing its own syntax based on existing programming languages,
CML then promotes the \emph{modeling-as-programming} approach. 

The UML \cite{uml} notation, on the other hand,
being graphical,
is not suited for mainstream, textual programming.
However, the \emph{Human Usable Textual Notation} (HUTN) \cite{hutn} is a textual syntax for MOF-based \cite{mof} metamodels,
and as such, it can also be used for UML models.
The syntax of the structural (static) elements of CML models is based on HUTN.

The OWL 2 standard, as another example, provides the Manchester \cite{owl2manchester} syntax,
which is intended to be user-friendly.
However, it does not resemble the syntax of commonly used, block-based, imperative programming languages,
such as C \cite{clang} and its syntax-alike descendants.
Manchester's syntax is also unlike the syntax of declarative, query languages, such as SQL \cite{sql}.

Using CML,
and its familiar syntax (as we shall demonstrate in the next sections),
it is expected that developers can raise the abstraction level of their programs.

\subsection{Language Evolution}

CML is expected to evolve with its compiler, and the tooling around it.
Unlike the expressive power seen on UML \cite{uml} and OWL 2 \cite{owl2} with their breadth of features,
the CML language and its extensible compiler intentionally support a limited number of features and scenarios.

This first version has been designed for the initial validation of the model-driven development approach taken by CML.
As developers provide feedback,
new language features may be iteratively added in order to enable the extensible CML compiler to support new modeling/development scenarios.

